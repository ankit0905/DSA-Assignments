// C++ program to find Index of 0 to be replaced with 1 to get
// longest continuous sequence of 1s in a binary array
#include<iostream>
using namespace std;
 
// Returns index of 0 to be replaced with 1 to get longest
// continuous sequence of 1s.  If there is no 0 in array, then
// it returns -1.
int maxOnesIndex(bool arr[], int n)
{
    int max_count = 0;  // for maximum number of 1 around a zero
    int max_index;  // for storing result
    int prev_zero = -1;  // index of previous zero
    int prev_prev_zero = -1; // index of previous to previous zero
 
    // Traverse the input array
    for (int curr=0; curr<n; ++curr)
    {
        // If current element is 0, then calculate the difference
        // between curr and prev_prev_zero
        if (arr[curr] == 0)
        {
            // Update result if count of 1s around prev_zero is more
            if (curr - prev_prev_zero > max_count)
            {
                max_count = curr - prev_prev_zero;
                max_index = prev_zero;
            }
 
            // Update for next iteration
            prev_prev_zero = prev_zero;
            prev_zero = curr;
        }
    }
 
    // Check for the last encountered zero
    if (n-prev_prev_zero > max_count)
       max_index = prev_zero;
 
    return max_index;
}
int main()
{
	int n,i;
	scanf("%d",&n);
	int arr[n];
	for(i=0; i<n; i++)
		scanf("%d",&arr[i]);
	int fl=0, ct=0, max=0, tmp1=-1, tmp2=-1, ans = -1;
	for(i=0; i<=n; i++){
		if(i==n){
			if(i-tmp2 > max){
				max = i-tmp2;
				ans = tmp1;
			}
		}
		else if(arr[i] == 0){
			if(i-tmp2 > max){
				max = i-tmp2;
				ans = tmp1;
			}
			tmp2 = tmp1;
			tmp1 = i;
		}
	}
	printf("%d\n",ans);
	return 0;
}
